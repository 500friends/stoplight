{"name":"Stoplight","tagline":"Traffic control for code.","body":"[![Gem version][2]][3]\r\n[![Build status][4]][5]\r\n[![Coverage status][6]][7]\r\n[![Quality status][8]][9]\r\n[![Dependency status][10]][11]\r\n\r\n<img align=\"right\" alt=\"Stoplight icon\" src=\"https://i.imgur.com/tiuOfY9.png\">\r\n\r\nTraffic control for code. An implementation of the circuit breaker pattern in\r\nRuby.\r\n\r\nCheck out [stoplight-admin][12] for controlling your stoplights.\r\n\r\n- [Installation](#installation)\r\n- [Setup](#setup)\r\n  - [Data store](#data-store)\r\n  - [Notifiers](#notifiers)\r\n  - [Rails](#rails)\r\n- [Basic usage](#basic-usage)\r\n  - [Custom errors](#custom-errors)\r\n  - [Custom fallback](#custom-fallback)\r\n  - [Custom threshold](#custom-threshold)\r\n  - [Custom timeout](#custom-timeout)\r\n  - [Rails](#rails-1)\r\n- [Advanced usage](#advanced-usage)\r\n  - [Locking](#locking)\r\n- [Credits](#credits)\r\n\r\n## Installation\r\n\r\nAdd it to your Gemfile:\r\n\r\n``` rb\r\ngem 'stoplight', '~> 0.4.1'\r\n```\r\n\r\nOr install it manually:\r\n\r\n``` sh\r\n$ gem install stoplight\r\n```\r\n\r\nThis project uses [Semantic Versioning][13].\r\n\r\n## Setup\r\n\r\n### Data store\r\n\r\nStoplight uses an in-memory data store out of the box.\r\n\r\n``` irb\r\n>> require 'stoplight'\r\n=> true\r\n>> Stoplight.data_store\r\n=> #<Stoplight::DataStore::Memory:...>\r\n```\r\n\r\nIf you want to use a persistent data store, you'll have to set it up. Currently\r\nthe only supported persistent data store is Redis. Make sure you have [the Redis\r\ngem][14] installed before configuring Stoplight.\r\n\r\n``` irb\r\n>> require 'redis'\r\n=> true\r\n>> redis = Redis.new(url: 'redis://127.0.0.1:6379/0')\r\n=> #<Redis:...>\r\n>> data_store = Stoplight::DataStore::Redis.new(redis)\r\n=> #<Stoplight::DataStore::Redis:...>\r\n>> Stoplight.data_store = data_store\r\n=> #<Stoplight::DataStore::Redis:...>\r\n```\r\n\r\n### Notifiers\r\n\r\nStoplight sends notifications to standard error by default.\r\n\r\n``` irb\r\n>> Stoplight.notifiers\r\n=> [#<Stoplight::Notifier::IO:...>]\r\n```\r\n\r\nIf you want to send notifications elsewhere, you'll have to set them up.\r\nCurrently the only other supported notifier is HipChat. Make sure you have [the\r\nHipChat gem][15] installed before configuring Stoplight.\r\n\r\n``` irb\r\n>> require 'hipchat'\r\n=> true\r\n>> hipchat = HipChat::Client.new('token')\r\n=> #<HipChat::Client:...>\r\n>> notifier = Stoplight::Notifier::HipChat.new(hipchat, 'room')\r\n=> #<Stoplight::Notifier::HipChat:...>\r\n>> Stoplight.notifiers << notifier\r\n=> [#<Stoplight::Notifier::IO:...>, #<Stoplight::Notifier::HipChat:...>]\r\n```\r\n\r\n### Rails\r\n\r\nStoplight is designed to work seamlessly with Rails. If you want to use the\r\nin-memory data store, you don't need to do anything special. If you want to use\r\na persistent data store, you'll need to configure it. Create an initializer for\r\nStoplight:\r\n\r\n``` rb\r\n# config/initializers/stoplight.rb\r\nrequire 'stoplight'\r\nStoplight.data_store = Stoplight::DataStore::Redis.new(...)\r\nStoplight.notifiers << Stoplight::Notifier::HipChat.new(...)\r\n```\r\n\r\n## Basic usage\r\n\r\nTo get started, create a stoplight:\r\n\r\n``` irb\r\n>> light = Stoplight::Light.new('example-1') { 22.0 / 7 }\r\n=> #<Stoplight::Light:...>\r\n```\r\n\r\nThen you can run it and it will return the result of calling the block. This is\r\nthe green state.\r\n\r\n``` irb\r\n>> light.run\r\n=> 3.142857142857143\r\n>> light.green?\r\n=> true\r\n```\r\n\r\nIf everything goes well, you shouldn't even be able to tell that you're using a\r\nstoplight. That's not very interesting though. Let's create a failing stoplight:\r\n\r\n``` irb\r\n>> light = Stoplight::Light.new('example-2') { 1 / 0 }\r\n=> #<Stoplight::Light:...>\r\n```\r\n\r\nNow when you run it, the error will be recorded and passed through. After\r\nrunning it a few times, the stoplight will stop trying and fail fast. This is\r\nthe red state.\r\n\r\n``` irb\r\n>> light.run\r\nZeroDivisionError: divided by 0\r\n>> light.run\r\nZeroDivisionError: divided by 0\r\n>> light.run\r\nZeroDivisionError: divided by 0\r\n>> light.run\r\nSwitching example-2 from green to red.\r\nStoplight::Error::RedLight: example-2\r\n>> light.red?\r\n=> true\r\n```\r\n\r\nWhen the stoplight changes from green to red, it will notify every configured\r\nnotifier.\r\n\r\n### Custom errors\r\n\r\nSome errors shouldn't cause your stoplight to move into the red state. Usually\r\nthese are handled elsewhere in your stack and don't represent real failures. A\r\ngood example is `ActiveRecord::RecordNotFound`.\r\n\r\n``` irb\r\n>> light = Stoplight::Light.new('example-4') { User.find(123) }.\r\n..   with_allowed_errors([ActiveRecord::RecordNotFound])\r\n=> #<Stoplight::Light:...>\r\n>> light.run\r\nActiveRecord::RecordNotFound: Couldn't find User with ID=123\r\n>> light.run\r\nActiveRecord::RecordNotFound: Couldn't find User with ID=123\r\n>> light.run\r\nActiveRecord::RecordNotFound: Couldn't find User with ID=123\r\n>> light.green?\r\n=> true\r\n```\r\n\r\n### Custom fallback\r\n\r\nInstead of raising a `Stoplight::Error::RedLight` error when in the red state,\r\nyou can provide a block to be run. This is useful when there's a good default\r\nvalue for the block.\r\n\r\n``` irb\r\n>> light = Stoplight::Light.new('example-5') { fail }.\r\n..   with_fallback { [] }\r\n=> #<Stoplight::Light:...>\r\n>> light.run\r\nRuntimeError:\r\n>> light.run\r\nRuntimeError:\r\n>> light.run\r\nRuntimeError:\r\n>> light.run\r\n=> []\r\n```\r\n\r\n### Custom threshold\r\n\r\nSome bits of code might be allowed to fail more or less frequently than others.\r\nYou can configure this by setting a custom threshold in seconds.\r\n\r\n``` irb\r\n>> light = Stoplight::Light.new('example-6') { fail }.\r\n..   with_threshold(1)\r\n=> #<Stoplight::Light:...>\r\n>> light.run\r\nRuntimeError:\r\n>> light.run\r\nStoplight::Error::RedLight: example-6\r\n```\r\n\r\n### Custom timeout\r\n\r\nStoplights will automatically attempt to recover after a certain amount of time.\r\nA light in the red state for longer than the timeout will transition to the\r\nyellow state. This timeout is customizable.\r\n\r\n``` irb\r\n>> light = Stoplight::Light.new('example-7') { fail }.\r\n..   with_timeout(1)\r\n=> #<Stoplight::Light:...>\r\n>> light.run\r\nRuntimeError:\r\n>> light.run\r\nRuntimeError:\r\n>> light.run\r\nRuntimeError:\r\n>> light.run\r\nSwitching example-7 from green to red.\r\nStoplight::Error::RedLight: example-7\r\n>> sleep(1)\r\n=> 1\r\n>> light.yellow?\r\n=> true\r\n>> light.run\r\nRuntimeError:\r\n```\r\n\r\nSet the timeout to `-1` to disable automatic recovery.\r\n\r\n### Rails\r\n\r\nStoplight was designed to wrap Rails actions with minimal effort. Here's an\r\nexample configuration:\r\n\r\n``` rb\r\nclass ApplicationController < ActionController::Base\r\n  around_action :stoplight\r\n  private\r\n  def stoplight(&block)\r\n    Stoplight::Light.new(\"#{params[:controller]}##{params[:action]}\", &block)\r\n      .with_allowed_errors([ActiveRecord::RecordNotFound])\r\n      .with_fallback { render(nothing: true, status: :service_unavailable) }\r\n      .run\r\n  end\r\nend\r\n```\r\n\r\n## Advanced usage\r\n\r\n### Locking\r\n\r\nAlthough stoplights can operate on their own, occasionally you may want to\r\noverride the default behavior. You can lock a light in either the green or red\r\nstate using `set_state`.\r\n\r\n``` irb\r\n>> light = Stoplight::Light.new('example-8') { true }\r\n=> #<Stoplight::Light:...>\r\n>> light.run\r\n=> true\r\n>> Stoplight.data_store.set_state(\r\n..   light.name, Stoplight::DataStore::STATE_LOCKED_RED)\r\n=> \"locked_red\"\r\n>> light.run\r\nSwitching example-8 from green to red\r\nStoplight::Error::RedLight: example-8\r\n```\r\n\r\n**Code in locked red lights may still run under certain conditions!** If you\r\nhave configured a custom data store and that data store fails, Stoplight will\r\nswitch over to using a blank in-memory data store. That means you will lose the\r\nlocked state of any stoplights.\r\n\r\n## Credits\r\n\r\nStoplight is brought to you by [@camdez][16] and [@tfausak][17] from\r\n[@OrgSync][18]. We were inspired by Martin Fowler's [CircuitBreaker][19]\r\narticle.\r\n\r\nIf this gem isn't cutting it for you, there are a few alternatives, including:\r\n[circuit_b][20], [circuit_breaker][21], [simple_circuit_breaker][22], and\r\n[ya_circuit_breaker][23].\r\n\r\n[1]: https://github.com/orgsync/stoplight\r\n[2]: https://badge.fury.io/rb/stoplight.svg\r\n[3]: https://rubygems.org/gems/stoplight\r\n[4]: https://travis-ci.org/orgsync/stoplight.svg\r\n[5]: https://travis-ci.org/orgsync/stoplight\r\n[6]: https://img.shields.io/coveralls/orgsync/stoplight.svg\r\n[7]: https://coveralls.io/r/orgsync/stoplight\r\n[8]: https://codeclimate.com/github/orgsync/stoplight/badges/gpa.svg\r\n[9]: https://codeclimate.com/github/orgsync/stoplight\r\n[10]: https://gemnasium.com/orgsync/stoplight.svg\r\n[11]: https://gemnasium.com/orgsync/stoplight\r\n[12]: https://github.com/orgsync/stoplight-admin\r\n[13]: http://semver.org/spec/v2.0.0.html\r\n[14]: https://rubygems.org/gems/redis\r\n[15]: https://rubygems.org/gems/hipchat\r\n[16]: https://github.com/camdez\r\n[17]: https://github.com/tfausak\r\n[18]: https://github.com/OrgSync\r\n[19]: http://martinfowler.com/bliki/CircuitBreaker.html\r\n[20]: https://github.com/alg/circuit_b\r\n[21]: https://github.com/wsargent/circuit_breaker\r\n[22]: https://github.com/soundcloud/simple_circuit_breaker\r\n[23]: https://github.com/wooga/circuit_breaker\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}