{"name":"Stoplight","tagline":"Traffic control for code.","body":"<p align=\"center\">\r\n  <img alt=\"Stoplight\" src=\"https://a.pomf.se/wdlzpt.svg\">\r\n</p>\r\n\r\n<p align=\"center\">\r\n  Stoplight is traffic control for code. It's an implementation of\r\n  the circuit breaker pattern in Ruby.\r\n</p>\r\n\r\n<p align=\"center\">\r\n  <a href=\"https://rubygems.org/gems/stoplight\">\r\n    <img alt=\"\" src=\"https://img.shields.io/gem/v/stoplight.svg\">\r\n  </a>\r\n  <a href=\"https://travis-ci.org/orgsync/stoplight\">\r\n    <img alt=\"\" src=\"https://img.shields.io/travis/orgsync/stoplight/master.svg\">\r\n  </a>\r\n  <a href=\"https://coveralls.io/r/orgsync/stoplight\">\r\n    <img alt=\"\" src=\"https://img.shields.io/coveralls/orgsync/stoplight/master.svg\">\r\n  </a>\r\n  <a href=\"https://codeclimate.com/github/orgsync/stoplight\">\r\n    <img alt=\"\" src=\"https://img.shields.io/codeclimate/github/orgsync/stoplight.svg\">\r\n  </a>\r\n  <a href=\"https://gemnasium.com/orgsync/stoplight\">\r\n    <img alt=\"\" src=\"https://img.shields.io/gemnasium/orgsync/stoplight.svg\">\r\n  </a>\r\n</p>\r\n\r\n<hr>\r\n\r\nCheck out [stoplight-admin][] for controlling your stoplights.\r\n\r\n- [Installation](#installation)\r\n- [Basic usage](#basic-usage)\r\n  - [Custom errors](#custom-errors)\r\n  - [Custom fallback](#custom-fallback)\r\n  - [Custom threshold](#custom-threshold)\r\n  - [Custom timeout](#custom-timeout)\r\n  - [Rails](#rails)\r\n- [Setup](#setup)\r\n  - [Data store](#data-store)\r\n  - [Notifiers](#notifiers)\r\n  - [Rails](#rails-1)\r\n- [Advanced usage](#advanced-usage)\r\n  - [Locking](#locking)\r\n- [Credits](#credits)\r\n\r\n## Installation\r\n\r\nAdd it to your Gemfile:\r\n\r\n``` rb\r\ngem 'stoplight', '~> 1.0'\r\n```\r\n\r\nOr install it manually:\r\n\r\n``` sh\r\n$ gem install stoplight --version '~> 1.0'\r\n```\r\n\r\n## Basic usage\r\n\r\nTo get started, create a stoplight:\r\n\r\n``` rb\r\nlight = Stoplight('example-1') { 22.0 / 7 }\r\n# => #<Stoplight::Light:...>\r\n```\r\n\r\nThen you can run it and it will return the result of calling the\r\nblock. This is the green state. (The green state corresponds to the\r\nclosed state for circuit breakers.)\r\n\r\n``` rb\r\nlight.run\r\n# => 3.142857142857143\r\nlight.color\r\n# => \"green\"\r\n```\r\n\r\nIf everything goes well, you shouldn't even be able to tell that\r\nyou're using a stoplight. That's not very interesting though. Let's\r\ncreate a failing stoplight:\r\n\r\n``` rb\r\nlight = Stoplight('example-2') { 1 / 0 }\r\n# => #<Stoplight::Light:...>\r\n```\r\n\r\nNow when you run it, the error will be recorded and passed through.\r\nAfter running it a few times, the stoplight will stop trying and\r\nfail fast. This is the red state. (The red state corresponds to the\r\nopen state for circuit breakers.)\r\n\r\n``` rb\r\nlight.run\r\n# ZeroDivisionError: divided by 0\r\nlight.run\r\n# ZeroDivisionError: divided by 0\r\nlight.run\r\n# Switching example-2 from green to red because ZeroDivisionError divided by 0\r\n# ZeroDivisionError: divided by 0\r\nlight.run\r\n# Stoplight::Error::RedLight: example-2\r\nlight.color\r\n# => \"red\"\r\n```\r\n\r\nWhen the stoplight changes from green to red, it will notify every\r\nconfigured notifier.\r\n\r\nThe stoplight will move into the yellow state after being in the\r\nred state for a while. (The yellow state corresponds to the half\r\nopen state for circuit breakers.) When stoplights are yellow, they'll\r\ntry to run their code. If it fails, they'll switch back to red. If\r\nit succeeds, they'll switch to green.\r\n\r\n### Custom errors\r\n\r\nSome errors shouldn't cause your stoplight to move into the red\r\nstate. Usually these are handled elsewhere in your stack and don't\r\nrepresent real failures. A good example is `ActiveRecord::RecordNotFound`.\r\n\r\n``` rb\r\nlight = Stoplight('example-3') { User.find(123) }\r\n  .with_allowed_errors([ActiveRecord::RecordNotFound])\r\n# => #<Stoplight::Light:...>\r\nlight.run\r\n# ActiveRecord::RecordNotFound: Couldn't find User with ID=123\r\nlight.run\r\n# ActiveRecord::RecordNotFound: Couldn't find User with ID=123\r\nlight.run\r\n# ActiveRecord::RecordNotFound: Couldn't find User with ID=123\r\nlight.color\r\n# => \"green\"\r\n```\r\n\r\n### Custom fallback\r\n\r\nBy default, stoplights will re-raise errors when they're green.\r\nWhen they're red, they'll raise a `Stoplight::Error::RedLight`\r\nerror. You can provide a fallback that will be called in both of\r\nthese cases. It will be passed the error if the light was green.\r\n\r\n``` rb\r\nlight = Stoplight('example-4') { 1 / 0 }\r\n  .with_fallback { |e| p e; 'default' }\r\n# => #<Stoplight::Light:..>\r\nlight.run\r\n# #<ZeroDivisionError: divided by 0>\r\n# => \"default\"\r\nlight.run\r\n# #<ZeroDivisionError: divided by 0>\r\n# => \"default\"\r\nlight.run\r\n# Switching example-4 from green to red because ZeroDivisionError divided by 0\r\n# #<ZeroDivisionError: divided by 0>\r\n# => \"default\"\r\nlight.run\r\n# nil\r\n# => \"default\"\r\n```\r\n\r\n### Custom threshold\r\n\r\nSome bits of code might be allowed to fail more or less frequently\r\nthan others. You can configure this by setting a custom threshold\r\nin seconds.\r\n\r\n``` rb\r\nlight = Stoplight('example-5') { fail }\r\n  .with_threshold(1)\r\n# => #<Stoplight::Light:...>\r\nlight.run\r\n# Switching example-5 from green to red because RuntimeError\r\n# RuntimeError:\r\nlight.run\r\n# Stoplight::Error::RedLight: example-5\r\n```\r\n\r\n### Custom timeout\r\n\r\nStoplights will automatically attempt to recover after a certain\r\namount of time. A light in the red state for longer than the timeout\r\nwill transition to the yellow state. This timeout is customizable.\r\n\r\n``` rb\r\nlight = Stoplight('example-6') { fail }\r\n  .with_timeout(1)\r\n# => #<Stoplight::Light:...>\r\nlight.run\r\n# RuntimeError:\r\nlight.run\r\n# RuntimeError:\r\nlight.run\r\n# Switching example-6 from green to red because RuntimeError\r\n# RuntimeError:\r\nsleep(1)\r\n# => 1\r\nlight.color\r\n# => \"yellow\"\r\nlight.run\r\n# RuntimeError:\r\n```\r\n\r\nSet the timeout to `-1` to disable automatic recovery.\r\n\r\n### Rails\r\n\r\nStoplight was designed to wrap Rails actions with minimal effort.\r\nHere's an example configuration:\r\n\r\n``` rb\r\nclass ApplicationController < ActionController::Base\r\n  around_action :stoplight\r\n  private\r\n  def stoplight(&block)\r\n    Stoplight(\"#{params[:controller]}##{params[:action]}\", &block)\r\n      .with_allowed_errors([ActiveRecord::RecordNotFound])\r\n      .with_fallback do |error|\r\n        Rails.logger.error(error)\r\n        render(nothing: true, status: :service_unavailable)\r\n      end\r\n      .run\r\n  end\r\nend\r\n```\r\n\r\n## Setup\r\n\r\n### Data store\r\n\r\nStoplight uses an in-memory data store out of the box.\r\n\r\n``` rb\r\nrequire 'stoplight'\r\n# => true\r\nStoplight::Light.default_data_store\r\n# => #<Stoplight::DataStore::Memory:...>\r\n```\r\n\r\nIf you want to use a persistent data store, you'll have to set it\r\nup. Currently the only supported persistent data store is Redis.\r\nMake sure you have [the Redis gem][] installed before configuring\r\nStoplight.\r\n\r\n``` rb\r\nrequire 'redis'\r\n# => true\r\nredis = Redis.new\r\n# => #<Redis client ...>\r\ndata_store = Stoplight::DataStore::Redis.new(redis)\r\n# => #<Stoplight::DataStore::Redis:...>\r\nStoplight::Light.default_data_store = data_store\r\n# => #<Stoplight::DataStore::Redis:...>\r\n```\r\n\r\n### Notifiers\r\n\r\nStoplight sends notifications to standard error by default.\r\n\r\n``` rb\r\nStoplight::Light.default_notifiers\r\n# => [#<Stoplight::Notifier::IO:...>]\r\n```\r\n\r\nIf you want to send notifications elsewhere, you'll have to set\r\nthem up. Currently the only other supported notifier is HipChat.\r\nMake sure you have [the HipChat gem][] installed before configuring\r\nStoplight.\r\n\r\n``` rb\r\nrequire 'hipchat'\r\n# => true\r\nhip_chat = HipChat::Client.new('token')\r\n# => #<HipChat::Client:...>\r\nnotifier = Stoplight::Notifier::HipChat.new(hip_chat, 'room')\r\n# => #<Stoplight::Notifier::HipChat:...>\r\nStoplight::Light.default_notifiers += [notifier]\r\n# => [#<Stoplight::Notifier::IO:...>, #<Stoplight::Notifier::HipChat:...>]\r\n```\r\n\r\n### Rails\r\n\r\nStoplight is designed to work seamlessly with Rails. If you want\r\nto use the in-memory data store, you don't need to do anything\r\nspecial. If you want to use a persistent data store, you'll need\r\nto configure it. Create an initializer for Stoplight:\r\n\r\n``` rb\r\n# config/initializers/stoplight.rb\r\nrequire 'stoplight'\r\nStoplight::Light.default_data_store = Stoplight::DataStore::Redis.new(...)\r\nStoplight::Light.default_notifiers += [Stoplight::Notifier::HipChat.new(...)]\r\n```\r\n\r\n## Advanced usage\r\n\r\n### Locking\r\n\r\nAlthough stoplights can operate on their own, occasionally you may\r\nwant to override the default behavior. You can lock a light in\r\neither the green or red state using `set_state`.\r\n\r\n``` rb\r\nlight = Stoplight('example-7') { true }\r\n# => #<Stoplight::Light:..>\r\nlight.run\r\n# => true\r\nlight.data_store.set_state(light, Stoplight::State::LOCKED_RED)\r\n# => \"locked_red\"\r\nlight.run\r\n# Stoplight::Error::RedLight: example-7\r\n```\r\n\r\n**Code in locked red lights may still run under certain conditions!**\r\nIf you have configured a custom data store and that data store\r\nfails, Stoplight will switch over to using a blank in-memory data\r\nstore. That means you will lose the locked state of any stoplights.\r\n\r\n## Credits\r\n\r\nStoplight is brought to you by [@camdez][] and [@tfausak][] from\r\n[@OrgSync][]. We were inspired by Martin Fowler's [CircuitBreaker][]\r\narticle.\r\n\r\n[stoplight-admin]: https://github.com/orgsync/stoplight-admin\r\n[the redis gem]: https://rubygems.org/gems/redis\r\n[the hipchat gem]: https://rubygems.org/gems/hipchat\r\n[@camdez]: https://github.com/camdez\r\n[@tfausak]: https://github.com/tfausak\r\n[@orgsync]: https://github.com/OrgSync\r\n[circuitbreaker]: http://martinfowler.com/bliki/CircuitBreaker.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}