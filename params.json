{"name":"Stoplight","tagline":"Traffic control for code.","body":"[![Gem version][2]][3]\r\n[![Build status][4]][5]\r\n[![Coverage status][6]][7]\r\n[![Quality status][8]][9]\r\n[![Dependency status][10]][11]\r\n\r\nStoplight is traffic control for code. It's an implementation of the circuit\r\nbreaker pattern in Ruby.\r\n\r\n<img align=\"right\" alt=\"Stoplight icon\" src=\"https://i.imgur.com/tiuOfY9.png\">\r\n\r\nCheck out [stoplight-admin][12] for controlling your stoplights.\r\n\r\n- [Installation](#installation)\r\n- [Setup](#setup)\r\n  - [Data store](#data-store)\r\n  - [Notifiers](#notifiers)\r\n  - [Rails](#rails)\r\n- [Basic usage](#basic-usage)\r\n  - [Custom errors](#custom-errors)\r\n  - [Custom fallback](#custom-fallback)\r\n  - [Custom threshold](#custom-threshold)\r\n  - [Custom timeout](#custom-timeout)\r\n  - [Rails](#rails-1)\r\n- [Advanced usage](#advanced-usage)\r\n  - [Locking](#locking)\r\n- [Credits](#credits)\r\n\r\n## Installation\r\n\r\nAdd it to your Gemfile:\r\n\r\n``` rb\r\ngem 'stoplight', '~> 0.5.1'\r\n```\r\n\r\nOr install it manually:\r\n\r\n``` sh\r\n$ gem install stoplight\r\n```\r\n\r\n## Setup\r\n\r\n### Data store\r\n\r\nStoplight uses an in-memory data store out of the box.\r\n\r\n``` rb\r\nrequire 'stoplight'\r\n# => true\r\nStoplight::Light.default_data_store\r\n# => #<Stoplight::DataStore::Memory:...>\r\n```\r\n\r\nIf you want to use a persistent data store, you'll have to set it up. Currently\r\nthe only supported persistent data store is Redis. Make sure you have [the Redis\r\ngem][13] installed before configuring Stoplight.\r\n\r\n``` rb\r\nrequire 'redis'\r\n# => true\r\nredis = Redis.new\r\n# => #<Redis client ...>\r\ndata_store = Stoplight::DataStore::Redis.new(redis)\r\n# => #<Stoplight::DataStore::Redis:...>\r\nStoplight::Light.default_data_store = data_store\r\n# => #<Stoplight::DataStore::Redis:...>\r\n```\r\n\r\n### Notifiers\r\n\r\nStoplight sends notifications to standard error by default.\r\n\r\n``` rb\r\nStoplight::Light.default_notifiers\r\n# => [#<Stoplight::Notifier::IO:...>]\r\n```\r\n\r\nIf you want to send notifications elsewhere, you'll have to set them up.\r\nCurrently the only other supported notifier is HipChat. Make sure you have [the\r\nHipChat gem][14] installed before configuring Stoplight.\r\n\r\n``` rb\r\nrequire 'hipchat'\r\n# => true\r\nhip_chat = HipChat::Client.new('token')\r\n# => #<HipChat::Client:...>\r\nnotifier = Stoplight::Notifier::HipChat.new(hip_chat, 'room')\r\n# => #<Stoplight::Notifier::HipChat:...>\r\nStoplight::Light.default_notifiers += [notifier]\r\n# => [#<Stoplight::Notifier::IO:...>, #<Stoplight::Notifier::HipChat:...>]\r\n```\r\n\r\n### Rails\r\n\r\nStoplight is designed to work seamlessly with Rails. If you want to use the\r\nin-memory data store, you don't need to do anything special. If you want to use\r\na persistent data store, you'll need to configure it. Create an initializer for\r\nStoplight:\r\n\r\n``` rb\r\n# config/initializers/stoplight.rb\r\nrequire 'stoplight'\r\nStoplight::Light.default_data_store = Stoplight::DataStore::Redis.new(...)\r\nStoplight::Light.default_notifiers += [Stoplight::Notifier::HipChat.new(...)]\r\n```\r\n\r\n## Basic usage\r\n\r\nTo get started, create a stoplight:\r\n\r\n``` rb\r\nlight = Stoplight::Light.new('example-1') { 22.0 / 7 }\r\n# => #<Stoplight::Light:...>\r\n```\r\n\r\nThen you can run it and it will return the result of calling the block. This is\r\nthe green state.\r\n\r\n``` rb\r\nlight.run\r\n# => 3.142857142857143\r\nlight.color\r\n# => \"green\"\r\n```\r\n\r\nIf everything goes well, you shouldn't even be able to tell that you're using a\r\nstoplight. That's not very interesting though. Let's create a failing stoplight:\r\n\r\n``` rb\r\nlight = Stoplight::Light.new('example-2') { 1 / 0 }\r\n# => #<Stoplight::Light:...>\r\n```\r\n\r\nNow when you run it, the error will be recorded and passed through. After\r\nrunning it a few times, the stoplight will stop trying and fail fast. This is\r\nthe red state.\r\n\r\n``` rb\r\nlight.run\r\n# ZeroDivisionError: divided by 0\r\nlight.run\r\n# ZeroDivisionError: divided by 0\r\nlight.run\r\n# Switching example-2 from green to red because ZeroDivisionError divided by 0\r\n# ZeroDivisionError: divided by 0\r\nlight.run\r\n# Stoplight::Error::RedLight: example-2\r\nlight.color\r\n# => \"red\"\r\n```\r\n\r\nWhen the stoplight changes from green to red, it will notify every configured\r\nnotifier.\r\n\r\n### Custom errors\r\n\r\nSome errors shouldn't cause your stoplight to move into the red state. Usually\r\nthese are handled elsewhere in your stack and don't represent real failures. A\r\ngood example is `ActiveRecord::RecordNotFound`.\r\n\r\n``` rb\r\nlight = Stoplight::Light.new('example-3') { User.find(123) }\r\n  .with_allowed_errors([ActiveRecord::RecordNotFound])\r\n# => #<Stoplight::Light:...>\r\nlight.run\r\n# ActiveRecord::RecordNotFound: Couldn't find User with ID=123\r\nlight.run\r\n# ActiveRecord::RecordNotFound: Couldn't find User with ID=123\r\nlight.run\r\n# ActiveRecord::RecordNotFound: Couldn't find User with ID=123\r\nlight.color\r\n# => \"green\"\r\n```\r\n\r\n### Custom fallback\r\n\r\nBy default, stoplights will re-raise errors when they're green. When they're\r\nred, they'll raise a `Stoplight::Error::RedLight` error. You can provide a\r\nfallback that will be called in both of these cases. It will be passed the error\r\nif the light was green.\r\n\r\n``` rb\r\nlight = Stoplight::Light.new('example-4') { 1 / 0 }\r\n  .with_fallback { |e| p e; 'default' }\r\n# => #<Stoplight::Light:..>\r\nlight.run\r\n# #<ZeroDivisionError: divided by 0>\r\n# => \"default\"\r\nlight.run\r\n# #<ZeroDivisionError: divided by 0>\r\n# => \"default\"\r\nlight.run\r\n# Switching example-4 from green to red because ZeroDivisionError divided by 0\r\n# #<ZeroDivisionError: divided by 0>\r\n# => \"default\"\r\nlight.run\r\n# nil\r\n# => \"default\"\r\n```\r\n\r\n### Custom threshold\r\n\r\nSome bits of code might be allowed to fail more or less frequently than others.\r\nYou can configure this by setting a custom threshold in seconds.\r\n\r\n``` rb\r\nlight = Stoplight::Light.new('example-5') { fail }\r\n  .with_threshold(1)\r\n# => #<Stoplight::Light:...>\r\nlight.run\r\n# Switching example-5 from green to red because RuntimeError\r\n# RuntimeError:\r\nlight.run\r\n# Stoplight::Error::RedLight: example-5\r\n```\r\n\r\n### Custom timeout\r\n\r\nStoplights will automatically attempt to recover after a certain amount of time.\r\nA light in the red state for longer than the timeout will transition to the\r\nyellow state. This timeout is customizable.\r\n\r\n``` rb\r\nlight = Stoplight::Light.new('example-6') { fail }\r\n  .with_timeout(1)\r\n# => #<Stoplight::Light:...>\r\nlight.run\r\n# RuntimeError:\r\nlight.run\r\n# RuntimeError:\r\nlight.run\r\n# Switching example-6 from green to red because RuntimeError\r\n# RuntimeError:\r\nsleep(1)\r\n# => 1\r\nlight.color\r\n# => \"yellow\"\r\nlight.run\r\n# RuntimeError:\r\n```\r\n\r\nSet the timeout to `-1` to disable automatic recovery.\r\n\r\n### Rails\r\n\r\nStoplight was designed to wrap Rails actions with minimal effort. Here's an\r\nexample configuration:\r\n\r\n``` rb\r\nclass ApplicationController < ActionController::Base\r\n  around_action :stoplight\r\n  private\r\n  def stoplight(&block)\r\n    Stoplight::Light.new(\"#{params[:controller]}##{params[:action]}\", &block)\r\n      .with_allowed_errors([ActiveRecord::RecordNotFound])\r\n      .with_fallback do |error|\r\n        Rails.logger.error(error)\r\n        render(nothing: true, status: :service_unavailable)\r\n      end\r\n      .run\r\n  end\r\nend\r\n```\r\n\r\n## Advanced usage\r\n\r\n### Locking\r\n\r\nAlthough stoplights can operate on their own, occasionally you may want to\r\noverride the default behavior. You can lock a light in either the green or red\r\nstate using `set_state`.\r\n\r\n``` rb\r\nlight = Stoplight::Light.new('example-7') { true }\r\n# => #<Stoplight::Light:..>\r\nlight.run\r\n# => true\r\nlight.data_store.set_state(light, Stoplight::State::LOCKED_RED)\r\n# => \"locked_red\"\r\nlight.run\r\n# Stoplight::Error::RedLight: example-7\r\n```\r\n\r\n**Code in locked red lights may still run under certain conditions!** If you\r\nhave configured a custom data store and that data store fails, Stoplight will\r\nswitch over to using a blank in-memory data store. That means you will lose the\r\nlocked state of any stoplights.\r\n\r\n## Credits\r\n\r\nStoplight is brought to you by [@camdez][15] and [@tfausak][16] from\r\n[@OrgSync][17]. We were inspired by Martin Fowler's [CircuitBreaker][18]\r\narticle.\r\n\r\n[1]: https://github.com/orgsync/stoplight\r\n[2]: https://img.shields.io/gem/v/stoplight.svg\r\n[3]: https://rubygems.org/gems/stoplight\r\n[4]: https://img.shields.io/travis/orgsync/stoplight/master.svg\r\n[5]: https://travis-ci.org/orgsync/stoplight\r\n[6]: https://img.shields.io/coveralls/orgsync/stoplight/master.svg\r\n[7]: https://coveralls.io/r/orgsync/stoplight\r\n[8]: https://img.shields.io/codeclimate/github/orgsync/stoplight.svg\r\n[9]: https://codeclimate.com/github/orgsync/stoplight\r\n[10]: https://img.shields.io/gemnasium/orgsync/stoplight.svg\r\n[11]: https://gemnasium.com/orgsync/stoplight\r\n[12]: https://github.com/orgsync/stoplight-admin\r\n[13]: https://rubygems.org/gems/redis\r\n[14]: https://rubygems.org/gems/hipchat\r\n[15]: https://github.com/camdez\r\n[16]: https://github.com/tfausak\r\n[17]: https://github.com/OrgSync\r\n[18]: http://martinfowler.com/bliki/CircuitBreaker.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}